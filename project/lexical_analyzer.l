/* Lexical Analyzer for Quirk24 */
/* lexical_analyzer.l */

/* Sabbir Ahmad */
/* ahmad.sab@husky.neu.edu */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser_generator.tab.h"       // header file for tokens generated by "parser_generator.y"

int yyerror(char *s);
int check_id_typeid(char *id);          // checks if a id is in saved typeid
int store_typeid(char *s);              // store typeid during scanning
int inittypeid();                       // initialize array to store typeid
char* extract_typeid_name(char *s);     // extract typeid from "protocol typeid", and return only "typeid"
char* manage_string(char *s);           // modify string for '\' and '\n' to be replaced by '\\' and '\\n' respectively 

//int yylineno = 1;                     // already define 
char **typeid_array;                    // array to store typeid
int initial_typeid_limit = 8;           // typeid limit initialized by 8, reallocated if more is needed
int typeid_count = 0;                   // number of typeid found

%}

%option noyywrap

digit		[0-9]
intliteral	{digit}+
id		[a-z][a-zA-Z0-9_]*
tvar		[A-Z][a-zA-Z0-9_]*
floatliteral    ([0-9]+\.[0-9]*([e][-+]?[0-9]+)?)|([0-9]*\.[0-9]+([e][-+]?[0-9]+)?)
charliteral     \'[ a-zA-Z0-9_~#$%&!()\"\*+\-\,\.\/\\:;<=>?@\[\]^\{\}~]\'
stringliteral   \"[ a-zA-Z0-9_~#$%&!()\n\r\'\*+\-\,\.\/\\:;<=>?@\[\]^\{\}~]*\"
typeid          protocol[ \t]+[a-z][a-zA-Z0-9_]*  

%%

{intliteral}	{ yylval.sval = strdup(yytext); return INTLITERAL; }
{floatliteral}	{ yylval.sval = strdup(yytext); return FLOATLITERAL; } 

{typeid}        { char *prt = extract_typeid_name(strdup(yytext)); store_typeid(prt); yylval.sval = strdup(prt); return PROTOCOL; }
"void"          { return VOID; }

"bool"|"char"|"string"|"int"|"float"            { yylval.sval = strdup(yytext); return PRIMTYPE; }

"null"          { return NULLVALUE; }
"true"          { return TRUE; }
"false"         { return FALSE; }

"constant"      { return CONSTANT; }
"static"        { return STATIC; }
"function"      { return FUNCTION; }
"protocol"      { yyerror("syntax error, unexpected PROTOCOL"); exit(1); }
"extends"       { return EXTENDS; }
"implements"    { return IMPLEMENTS; }
"fun"           { return FUN; }
"class"         { return CLASS; }
"return"        { return RETURN; }
"if"            { return IF; }
"else"          { return ELSE; }
"while"         { return WHILE; }
"for"           { return FOR; }
"halt"          { return HALT; }
"new"           { return NEW; }
"lambda"        { return LAMBDA; }


{id}		{ yylval.sval = strdup(yytext);
                        if (check_id_typeid(strdup(yytext)) == 1) { return TYPEID; }
                        else { return ID; }
                }

{tvar}		{ yylval.sval = strdup(yytext); return TVAR; }
"->"		{ return ARROW; }
"||"		{ yylval.sval = strdup(yytext); return OROP; }
"&&"		{ yylval.sval = strdup(yytext); return ANDOP; }
"=="            { yylval.sval = strdup("="); return RELOP; }
"!="|"<="|">="  { yylval.sval = strdup(yytext); return RELOP; }
"<"		{ yylval.sval = strdup(yytext); return LANGLE; }
">"		{ yylval.sval = strdup(yytext); return RANGLE; }
"="		{ yylval.sval = strdup(yytext); return ASSIGNOP; }
"+"		{ yylval.sval = strdup(yytext); return ADDOP; }
"*"|"/"		{ yylval.sval = strdup(yytext); return MULOP; }
"!"		{ yylval.sval = strdup(yytext); return UNOP; }
"-"		{ yylval.sval = strdup(yytext); return MINUS; }
";"		{ return SEMICOLON; }
":"		{ return COLON; }
","		{ return COMMA; }
"("		{ return LPAR; }
")"		{ return RPAR; }
"{"		{ return LBRACE; }
"}"		{ return RBRACE; }
"["		{ return LBRACKET; }
"]"		{ return RBRACKET; }
\.		{ return DOT; }
\/\/.*		{ /* This is comment */ }
{charliteral}   { yylval.sval = strdup(yytext); return CHARLITERAL; } 
{stringliteral} { char *str = manage_string(strdup(yytext)); yylval.sval = strdup(str); return STRINGLITERAL; } 
[ \t]*		{ /* White space*/ }
[\n]		{ yylineno++; }

.		{ yyerror(""); exit(1); }

%%

char* manage_string(char *s)  // modify string for '\' and '\n' to be replaced by '\\' and '\\n' respectively
{
        int l = strlen(s);
        int str_l = 2*l;
        char *str = (char*) malloc(str_l);
        int j = 0;
        int i;
        for(i=0; i<l; i++)
        {
                if (j >= str_l)
                {
                        str_l = str_l*2;
                        str = (char *) realloc (str, str_l);
                }
                if(s[i] == '\\')
                {
                        str[j++] = '\\';              
                        str[j++] = '\\';
                }
                else if(s[i] == '\n')
                {
                        str[j++] = '\\';
                        str[j++] = 'n';
                        yylineno++;
                }
                else
                {
                        str[j++] = s[i];
                }
        }
        str[j] = '\0';

        return str;
}

char* extract_typeid_name(char *s)  // extract typeid from "protocol typeid", and return only "typeid"
{
        char *token;
        char *str = strdup(s);
        token = strtok(str, " ");
        token = strtok(NULL, " ");
        
        return token;
}

int inittypeid()  // initialize array to store typeid
{
        typeid_array = (char **) malloc (sizeof(char *) * initial_typeid_limit);
        return 0;
}

int store_typeid(char *s)  // store typeid during scanning
{
        if (typeid_count >= initial_typeid_limit)
        {
                initial_typeid_limit = 2 * initial_typeid_limit;
                typeid_array = (char **) realloc (typeid_array, sizeof(char *) * initial_typeid_limit);
        }

        typeid_array[typeid_count] = strdup(s);
        typeid_count++;
        return 1;
}

int check_id_typeid(char *id)  // checks if a id is in saved typeid 
{
        int i;
        for (i = 0; i < typeid_count; i++) 
        {
                if (!strcmp(id, typeid_array[i]))    // see if the id matches with any typeid
                {
                        return 1;   // matches with one of the typeid and returns 1
                }
        }
        return 0;   // doesn't match with any typeid and returns 0
} 


// main function only to check if lexical analyzer works fine
/*
int main(int argc, char **argv)
{
  if ((argc > 1) && (freopen(argv[1], "r", stdin) == NULL))
  {
    fprintf(stderr, "argv[0]: File %s cannot be opened.\n", argv[1]) ;
    exit( 1 );
  }
  while(yylex());
  printf("\nLines: %d", yylineno);

  return 0;
}
*/


